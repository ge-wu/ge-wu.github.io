[{"title":"Leetcode Weekly Contest 236","url":"/2021/04/11/Leetcode-Weekly-Contest-236/","content":"1822. Sign of the Product of an ArrayElementary math. Count number of negative integers and check whether it is even or odd. \nclass Solution &#123;public:    int arraySign(vector&lt;int&gt;&amp; nums) &#123;        int a = 0;        for (int n: nums) &#123;            if (!n) return 0;            if (n &lt; 0) a++;        &#125;        return a &amp; 1 ? -1 : 1;    &#125;&#125;;\nTime complexity: O(n)\n1823. Find the Winner of the Circular GameUse a queue to simulate the process, straightforward. \nclass Solution &#123;public:    int findTheWinner(int n, int k) &#123;        queue&lt;int&gt; q;        for (int i = 1; i &lt;= n; i++) q.push(i);                while (q.size() &gt; 1) &#123;            for (int i = 0; i &lt; k - 1; i++) &#123;                int x = q.front(); q.pop();                q.push(x);            &#125;            q.pop();        &#125;        return q.front();    &#125;&#125;;\nTime complexity: O(n)\n1824. Minimum Sideway JumpsBasic type dynamic programming. Maintain three entries, a, b, and c, where each entry represents the minimum jump to reach to the end of each line. Initialize a=1 and c=1 are because we start on lane 2, and we need a jump to go to lane 1 or lane 3. For the dynamic transfer, letâ€™s say on the first lane, a and the ith obstacle. If ith obstacle is not on lane a, then there must be a jump from lane b or lane c, and we find the minimum between them. \nclass Solution &#123;public:    int minSideJumps(vector&lt;int&gt;&amp; obstacles) &#123;        int a = 1, b = 0, c = 1;        for (int obs: obstacles) &#123;            if (obs == 1) a = INT_MAX / 2;            if (obs == 2) b = INT_MAX / 2;            if (obs == 3) c = INT_MAX / 2;                        if (obs != 1) a = min(a, min(b + 1, c + 1));            if (obs != 2) b = min(b, min(a + 1, c + 1));            if (obs != 3) c = min(c, min(a + 1, b + 1));        &#125;        return min(a, min(b, c));    &#125;&#125;;\nTime complexity: O(n)\n1825. Finding MK AverageUse three queries (multiset) to store : small numbers, middle numbers, and large numbers, respectively, and a queue for all numbers. Initialize three queries when there are enough m elements. Update each query if there are more than m elements. Similar question: 295. Find Median from Data Stream. \nclass MKAverage &#123;public:    vector&lt;int&gt; q;    int m, k;    struct query &#123;        multiset&lt;int&gt; s;        long long sum = 0;        void insert(int n) &#123;            s.insert(n);            sum += n;        &#125;        void remove(int n) &#123;            s.erase(s.find(n));            sum -= n;        &#125;    &#125; left, mid, right;    MKAverage(int m, int k): m(m), k(k) &#123;&#125;    void addElement(int num) &#123;        q.push_back(num);        if (q.size() &lt; m) return;        // Initialize queries        if (q.size() == m) &#123;            auto w = q;            sort(w.begin(), w.end());            for (int i = 0; i &lt; k; i++) left.insert(w[i]);            for (int i = k; i &lt; m - k; i++) mid.insert(w[i]);            for (int i = m - k; i &lt; m; i++) right.insert(w[i]);        &#125; else &#123;            /* Insert to mid no matter what, then rearrange that new element by             compare with left most of the right query and right most of the             left query. */            mid.insert(num);             int lr = *left.s.rbegin(), rl = *right.s.begin();            int ml = *mid.s.begin(), mr = *mid.s.rbegin();            if (ml &lt; lr) &#123;                mid.remove(ml), left.remove(lr);                mid.insert(lr), left.insert(ml);            &#125;            if (mr &gt; rl) &#123;                mid.remove(mr), right.remove(rl);                mid.insert(rl), right.insert(mr);            &#125;            // Remove the oldest element in the window            int temp = q[q.size() - m - 1];            if (mid.s.count(temp)) mid.remove(temp);            else if (left.s.count(temp)) &#123;                left.remove(temp);                int x = *mid.s.begin();                mid.remove(x), left.insert(x);            &#125; else &#123;                right.remove(temp);                int x = *mid.s.rbegin();                mid.remove(x), right.insert(x);            &#125;        &#125;    &#125;    int calculateMKAverage() &#123;        if (q.size() &lt; m) return -1;        return mid.sum / mid.s.size();    &#125;&#125;;\nTime complexity: MKAverage and calculateMKAverage are O(1) and addElement is O(log n)\n","tags":["problem solving","leetcode","algorithm"]}]