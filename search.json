[{"title":"Leetcode Weekly Contest 236","url":"/2021/04/11/Leetcode-Weekly-Contest-236/","content":"1822. Sign of the Product of an ArrayElementary math. Count number of negative integers and check whether it is even or odd. \nclass Solution &#123;public:    int arraySign(vector&lt;int&gt;&amp; nums) &#123;        int a = 0;        for (int n: nums) &#123;            if (!n) return 0;            if (n &lt; 0) a++;        &#125;        return a &amp; 1 ? -1 : 1;    &#125;&#125;;\nTime complexity: O(n)\n1823. Find the Winner of the Circular GameUse a queue to simulate the process, straightforward. \nclass Solution &#123;public:    int findTheWinner(int n, int k) &#123;        queue&lt;int&gt; q;        for (int i = 1; i &lt;= n; i++) q.push(i);                while (q.size() &gt; 1) &#123;            for (int i = 0; i &lt; k - 1; i++) &#123;                int x = q.front(); q.pop();                q.push(x);            &#125;            q.pop();        &#125;        return q.front();    &#125;&#125;;\nTime complexity: O(n)\n1824. Minimum Sideway JumpsBasic type dynamic programming. Maintain three entries, a, b, and c, where each entry represents the minimum jump to reach to the end of each line. Initialize a=1 and c=1 are because we start on lane 2, and we need a jump to go to lane 1 or lane 3. For the dynamic transfer, let’s say on the first lane, a and the ith obstacle. If ith obstacle is not on lane a, then there must be a jump from lane b or lane c, and we find the minimum between them. \nclass Solution &#123;public:    int minSideJumps(vector&lt;int&gt;&amp; obstacles) &#123;        int a = 1, b = 0, c = 1;        for (int obs: obstacles) &#123;            if (obs == 1) a = INT_MAX / 2;            if (obs == 2) b = INT_MAX / 2;            if (obs == 3) c = INT_MAX / 2;                        if (obs != 1) a = min(a, min(b + 1, c + 1));            if (obs != 2) b = min(b, min(a + 1, c + 1));            if (obs != 3) c = min(c, min(a + 1, b + 1));        &#125;        return min(a, min(b, c));    &#125;&#125;;\nTime complexity: O(n)\n1825. Finding MK AverageUse three queries (multiset) to store : small numbers, middle numbers, and large numbers, respectively, and a queue for all numbers. Initialize three queries when there are enough m elements. Update each query if there are more than m elements. Similar question: 295. Find Median from Data Stream. \nclass MKAverage &#123;public:    vector&lt;int&gt; q;    int m, k;    struct query &#123;        multiset&lt;int&gt; s;        long long sum = 0;        void insert(int n) &#123;            s.insert(n);            sum += n;        &#125;        void remove(int n) &#123;            s.erase(s.find(n));            sum -= n;        &#125;    &#125; left, mid, right;    MKAverage(int m, int k): m(m), k(k) &#123;&#125;    void addElement(int num) &#123;        q.push_back(num);        if (q.size() &lt; m) return;        // Initialize queries        if (q.size() == m) &#123;            auto w = q;            sort(w.begin(), w.end());            for (int i = 0; i &lt; k; i++) left.insert(w[i]);            for (int i = k; i &lt; m - k; i++) mid.insert(w[i]);            for (int i = m - k; i &lt; m; i++) right.insert(w[i]);        &#125; else &#123;            /* Insert to mid no matter what, then rearrange that new element by             compare with left most of the right query and right most of the             left query. */            mid.insert(num);             int lr = *left.s.rbegin(), rl = *right.s.begin();            int ml = *mid.s.begin(), mr = *mid.s.rbegin();            if (ml &lt; lr) &#123;                mid.remove(ml), left.remove(lr);                mid.insert(lr), left.insert(ml);            &#125;            if (mr &gt; rl) &#123;                mid.remove(mr), right.remove(rl);                mid.insert(rl), right.insert(mr);            &#125;            // Remove the oldest element in the window            int temp = q[q.size() - m - 1];            if (mid.s.count(temp)) mid.remove(temp);            else if (left.s.count(temp)) &#123;                left.remove(temp);                int x = *mid.s.begin();                mid.remove(x), left.insert(x);            &#125; else &#123;                right.remove(temp);                int x = *mid.s.rbegin();                mid.remove(x), right.insert(x);            &#125;        &#125;    &#125;    int calculateMKAverage() &#123;        if (q.size() &lt; m) return -1;        return mid.sum / mid.s.size();    &#125;&#125;;\nTime complexity: O(log n)\n","tags":["leetcode"]},{"title":"Leetcode Weekly Contest 248","url":"/2021/07/03/Leetcode-Weekly-Contest-248/","content":"5800. Build Array from PermutationStraightforward.\nclass Solution &#123;public:    vector&lt;int&gt; buildArray(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; ans;        for (int n: nums) &#123;            ans.push_back(nums[n]);        &#125;        return ans;    &#125;&#125;;\n5801. Eliminate Maximum Number of MonstersGreedy. First calculate the time for each monster to arrive, i.e. time = distance / speed. Since we can kill any monster, therefore we want to kill the earliest monster that can be reached. If more than one monster arrived at current time, then the game is over.  \nclass Solution &#123;public:    int eliminateMaximum(vector&lt;int&gt;&amp; dist, vector&lt;int&gt;&amp; speed) &#123;        int curTime = 0, n = dist.size();        vector&lt;int&gt; times;        for (int i = 0; i &lt; n; ++i) &#123;            times.push_back(ceil(1.0 * dist[i] / speed[i]));        &#125;        sort(times.begin(), times.end());        for (int i = 0; i &lt; n; ++i) &#123;            if (curTime++ &gt;= times[i]) &#123;                return i;            &#125;        &#125;        return n;    &#125;&#125;;\n5802. Count Good NumbersBasic idea is counting. Five candidates for even indices, and four candidates for odd indices. That is, (5x4x5x...)%mod. In general, there are ceil(n/2) (in case n is odd) five’s and n/2 four’s. The tricky part is n can be 10^15, and the pow() from math library will give us TLE. \nNote that for 4^10, we can convert this to (1024)^2, hence the time complexity is O(log n).\n#define ll long long#define mod 1000000007class Solution &#123;public:    int countGoodNumbers(ll n) &#123;        ll x = ceil(1.0 * n / 2), y = n / 2;        ll a = fastPower(5, x), b = fastPower(4, y);        return (a * b) % mod;    &#125;    int fastPower(ll b, ll p) &#123;        ll ans = 1;        while (p) &#123;            if (p &amp; 1) &#123;                ans = (ans * b) % mod;            &#125;            b = (b * b) % mod;            p /= 2;        &#125;        return ans;    &#125;&#125;;\n5803. Longest Common SubpathDNF. I will come back later. \n","tags":["leetcode"]},{"title":"Leetcode Weekly Contest 237","url":"/2021/04/17/Leetcode-Weekly-Contest-237/","content":"1832. Check if the Sentence Is PangramStraightforward. \nclass Solution &#123;public:    bool checkIfPangram(string sentence) &#123;        set&lt;char&gt; s;        for (char c: sentence) &#123;            s.insert(c - &#x27;a&#x27;);        &#125;        return s.size() == 26;    &#125;&#125;;\nTime complexity: O(n)\n1833. Maximum Ice Cream BarsGreedy. \nclass Solution &#123;public:    int maxIceCream(vector&lt;int&gt;&amp; costs, int coins) &#123;        int total = 0, ans = 0;        sort(costs.begin(), costs.end());        for (int i = 0; i &lt; costs.size(); i++) &#123;            total += costs[i];            if (total &gt; coins)                return i;            ans++;        &#125;        return ans;    &#125;&#125;;\nTime complexity: O(n)\n1834. Single-Threaded CPUHeap. Sort the array by the enqueue time. Keep track  of a current time. Push all the tasks that enqueue time is less or equal than the current time. Reference: SJF scheduling learned from an OS course.  \ntypedef pair&lt;int, int&gt; PII;typedef long long ll;class Solution &#123;public:    vector&lt;int&gt; getOrder(vector&lt;vector&lt;int&gt;&gt;&amp; t) &#123;        priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;&gt;&gt; pq;        ll n = t.size(), cur_time = 0, i = 0;        for (int i = 0; i &lt; n; i++) &#123;            t[i].push_back(i);        &#125;        sort(t.begin(), t.end());        vector&lt;int&gt; ans;        while (i &lt; n || pq.size()) &#123;            if (pq.empty()) &#123;                cur_time = max(cur_time, (ll) t[i][0]);            &#125;            while (i &lt; n &amp;&amp; cur_time &gt;= t[i][0]) &#123;                pq.push(&#123;t[i][1], t[i][2]&#125;);                i++;            &#125;            PII cur = pq.top(); pq.pop();            cur_time += cur.first;            ans.push_back(cur.second);        &#125;        return ans;    &#125;&#125;;\nTime complexity: O(nlogn)\n1835. Find XOR Sum of All Pairs Bitwise ANDSimple discrete math, i.e.(a &amp; b1) ^ (a &amp; b2) = a &amp; (b1 ^ b2) \nclass Solution &#123;public:    int getXORSum(vector&lt;int&gt;&amp; arr1, vector&lt;int&gt;&amp; arr2) &#123;        int x = 0;        for (int n: arr2) &#123;            x ^= n;        &#125;        int ans = 0;        for (int n: arr1) &#123;            ans ^= (n &amp; x);        &#125;        return ans;    &#125;&#125;;\nTime complexity: O(n)\n","tags":["leetcode"]}]